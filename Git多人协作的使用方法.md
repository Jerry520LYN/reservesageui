## GitHub 团队协作流程
### 1\. 核心协作理念：分支 (Branching)

首先要理解最重要的一个概念：**分支 (Branch)**。

想象一下你的项目是一棵大树的主干 (`main` 分支)。如果每个人都直接在主干上修改，很容易会互相影响，造成混乱。

正确的做法是，每个人在接到一个新任务时，都从主干上**分叉出一个自己的新树枝 (Branch)**。然后，你在这根属于你的树枝上进行所有的修改、添加代码 (`add`, `commit`)。当你完成任务并且测试通过后，再申请把你这根树枝\*\*合并 (Merge)\*\*回主干。

**这样做的好处：**

  * **隔离开发**：你在你的分支上工作，不会影响到主干，也不会影响到其他人。
  * **并行工作**：你负责登录功能，你的同伴可以同时在另一个分支上负责用户界面，互不干扰。
  * **代码审查**：在合并回主干之前，可以有一个“请求合并”的步骤（Pull Request），让其他人检查你的代码，确保质量。

-----

### 2\. GitHub 上的准备工作：邀请合作者

在你自己的 GitHub 项目页面上，你需要授权给你的合作者，让他们有权限向你的项目仓库提交代码。

1.  打开你的 GitHub 项目主页。
2.  点击右上角的 **Settings** (设置)。
3.  在左侧菜单中，点击 **Collaborators** (合作者)。
4.  点击 **Add people** (添加用户) 按钮。
5.  输入你合作者的 GitHub 用户名、全名或电子邮件，然后从下拉列表中选择他们，并点击邀请。
6.  对方会收到一封邮件，接受邀请后，他们就有了向这个仓库推送 (push) 代码的权限。

-----

### 3\. 团队协作的核心 Git 命令与流程

这是你需要学习和掌握的核心命令和工作流程。

#### A. 合作者要做的第一件事：克隆项目

你的同伴需要先把项目从 GitHub 下载到他们自己的电脑上。

```bash
# 把 <你的项目URL> 替换成你项目的实际URL
git clone <你的项目URL>
```

#### B. 完整的日常开发流程 (最关键的部分)

假设你要开发一个“用户登录”的新功能，你应该这样做：

**第1步：确保你的本地代码是最新版本**
在开始新工作前，永远先从服务器上拉取最新的代码，确保你的主干分支 (`main` 或 `master`) 是和 GitHub 上完全同步的。

```bash
# 首先，切换到主分支
git checkout main

# 从远程仓库（GitHub）拉取最新的更新
git pull origin main
```

**第2步：为你现在要做的任务，创建一个新的分支**
分支名最好有意义，比如 `feature/user-login` 或 `fix/login-bug`。

```bash
# 创建并立即切换到这个新分支
git checkout -b feature/user-login
```

*(这条命令是 `git branch feature/user-login` 和 `git checkout feature/user-login` 两条命令的简写)*

**第3步：在新分支上安心工作**
现在，你可以尽情地修改、添加文件了。这个过程和你之前单人工作时一样。

```bash
# (你在这里修改或创建了文件...)

# 添加你的修改到暂存区（你提到的“缓冲区”）
git add .

# 提交你的修改，并写清楚这次提交做了什么
git commit -m "完成用户登录后端逻辑"
```

你可以多次 `add` 和 `commit`，直到这个功能开发完成。

**第4步：将你的分支推送到 GitHub**
当你觉得这个功能做得差不多了，就可以把它推送到 GitHub 上，让其他人看到你的这个分支。

```bash
# -u 的作用是建立本地分支和远程分支的链接，以后推送这个分支只需要 git push
git push -u origin feature/user-login
```

**第5步：在 GitHub 上创建“合并请求” (Pull Request)**
推送完成后，打开你的 GitHub 项目页面，你会看到一个黄色的提示条，告诉你刚刚推送了一个新分支，并建议你创建一个 **Pull Request (PR)**。

点击 "Compare & pull request" 按钮。你会进入一个新页面，在这里：

  * **标题和描述**：清晰地写下你在这个分支里做了什么，解决了什么问题。
  * **Reviewers (审查者)**：在右侧指定你的同伴来检查你的代码。
  * **Assignees (负责人)**：可以指定这个任务的负责人（通常是你自己）。

创建 PR 后，你的同伴会收到通知。他可以在 PR 页面里逐行检查你的代码，提出修改意见，并与你讨论。

**第6步：合并分支 (Merge Pull Request)**
当你的同伴觉得你的代码没问题后，他会 "Approve" (批准) 这个 PR。然后，拥有权限的人（通常是你或者项目管理员）就可以点击绿色的 **"Merge pull request"** 按钮。

点击后，GitHub 会自动地把你 `feature/user-login` 分支上的所有修改合并到 `main` 主分支里。

**第7步：清理工作**
合并成功后，这个功能分支就完成了它的历史使命。你可以在 GitHub 上直接删除这个远程分支，然后在你的本地也删除它。

```bash
# 切换回主分支
git checkout main

# （可选）拉取一下最新的主分支（包含了刚才合并的代码）
git pull origin main

# 删除你本地的那个已经用完的分支
git branch -d feature/user-login
```

**总结一下，你的每一次任务循环都是：`pull` -\> `checkout -b` -\> `add/commit` -\> `push` -\> `Pull Request` -\> `merge`。**

-----

### 4\. 如何划分任务与明确责任 (GitHub Issues & Projects)

Git 本身只管理代码，而 GitHub 提供了一套强大的项目管理工具来解决“谁负责什么”的问题。

  * **使用 Issues (议题)**

      * 在你的项目主页，点击 **Issues** 标签页。
      * 你可以把每一个要开发的功能、要修复的 Bug，都创建一个 Issue。
      * 在创建 Issue 时，你可以在右侧的 **Assignees** 栏把它**指派**给某个合作者。这样每个人就都清楚自己要做什么了。
      * 你们可以在 Issue 下方进行讨论，跟踪进度。当相关的 Pull Request 被合并后，你甚至可以在 PR 描述里写 `Closes #议题编号`，这样 PR 合并后对应的 Issue 就会自动关闭，形成一个完美闭环。

  * **使用 Projects (项目看板)**

      * 在 Issues 的旁边有 **Projects** 标签页。
      * 你可以创建一个项目看板（类似 Trello 或看板），比如分为 "To Do" (待办)、"In Progress" (进行中)、"Done" (已完成) 这几列。
      * 然后把你们创建的 Issues 以卡片的形式拖到这个看板上。这样整个项目的进度就一目了然了。

-----

### 5\. 如何追溯谁做了什么 (Commit History & Blame)

这是 Git 和 GitHub 的核心优势之一，你完全不用担心分不清楚谁做了什么。

  * **Commit History (提交历史)**

      * 你在 GitHub 上点击任何一个文件，然后点击右上角的 "History" 按钮，就能看到这个文件的所有修改历史，包括**谁 (who)** 在**什么时间 (when)** 做了**什么修改 (what)**。
      * 在命令行，你可以使用 `git log` 查看整个项目的提交历史。

  * **Blame (追溯)**

      * 在 GitHub 上查看一个文件时，点击 "Blame" 按钮。
      * 这会显示文件的每一行代码**最后是由谁在哪一次提交中修改的**。这对于查找引入 Bug 的代码非常有用。

### 总结你需要学习的 Git 命令

为了协作，你需要在你已有知识的基础上，重点学习和理解以下命令：

  * `git clone`: 克隆远程仓库到本地。
  * `git pull`: 从远程仓库拉取最新更改。
  * `git branch`: 管理分支（创建、查看、删除）。
  * `git checkout`: 切换分支。
  * `git push`: 将本地提交推送到远程仓库。
  * `git merge`: （虽然 GitHub 按钮会帮你做，但理解其概念很重要）合并分支。

## 如何回退
在 Git 中，回退操作是日常开发中非常重要的技能。根据你的具体场景和需求，有多种不同的回退方法。下面为你详细介绍最常用的几种方法及其区别。

-----

### 1\. git reset：撤销本地提交，改变提交历史

`git reset` 是一个强大的命令，它可以将当前分支的 `HEAD` 指针和相关内容重置到指定的提交状态。这个命令会 **永久性地删除** 之后的提交记录，所以在使用时需要格外小心，尤其是在公共分支上。

它有三个常用的参数：

  * **`git reset --soft <commit_id>`**

      * **作用：** 撤销指定的提交，但 **保留** 更改到暂存区（Staging Area）。
      * **适用场景：** 你想撤销一次提交，但保留所有修改，以便重新组织或重新提交。
      * **效果：** 你的工作目录和暂存区中的文件都没有变化，但 `git status` 会显示所有被撤销的提交所包含的更改，并准备好再次提交。

  * **`git reset --mixed <commit_id>` (默认选项)**

      * **作用：** 撤销指定的提交，并 **保留** 更改到工作区（Working Directory）。
      * **适用场景：** 你想撤销一次提交，并且想从头开始重新修改和提交。
      * **效果：** 你的工作目录中的文件没有变化，但暂存区会被清空。所有被撤销的提交所包含的更改都会回到你的工作区，显示为未暂存的更改。

  * **`git reset --hard <commit_id>`**

      * **作用：** **彻底** 撤销指定的提交，并 **丢弃** 所有更改。
      * **适用场景：** 你确定要完全放弃某个提交以及之后的所有更改。
      * **效果：** 你的工作区和暂存区都会被重置到指定提交的状态，所有后续的更改都会被 **永久删除**。这个命令非常危险，请务必谨慎使用。

**如何使用：**

1.  首先，使用 `git log` 或 `git log --oneline` 找到你想回退到的那个提交的 **ID**。
2.  然后，执行对应的 `git reset` 命令。例如，回退到上一个版本：
    ```bash
    git reset --hard HEAD^
    ```
    或者回退到指定的提交：
    ```bash
    git reset --hard <commit_id>
    ```

-----

### 2\. git revert：创建一个新的提交来撤销之前的更改

`git revert` 是另一种回退方式，它不会删除历史提交，而是创建一个 **新的提交**，这个新提交会撤销或抵消之前指定提交所做的所有更改。

  * **作用：** 在不改变历史记录的情况下，安全地撤销某个提交。
  * **适用场景：** 当你已经将提交 `push` 到远程仓库，并且有其他协作者在使用这个分支时。使用 `git reset` 会导致历史记录混乱，而 `git revert` 更加安全。
  * **效果：** `git log` 中会增加一个新的提交记录，明确地表示“撤销了某个提交”，原始提交仍然存在于历史中。

**如何使用：**

1.  使用 `git log` 找到你想撤销的那个提交的 **ID**。
2.  执行 `git revert` 命令：
    ```bash
    git revert <commit_id>
    ```
3.  Git 会打开一个编辑器，让你输入新提交的提交信息，默认会帮你生成一个。保存并退出即可完成。

-----

### 3\. git reflog：恢复被“回退”的操作

如果你不小心使用了 `git reset --hard` 删除了重要的提交，不要慌！`git reflog` 是你的救命稻草。它会记录你所有对 `HEAD` 的操作，包括分支切换、提交、以及各种 `reset` 操作。

  * **作用：** 查看你的操作历史，包括那些已经被 `git log` 隐藏的提交。
  * **适用场景：** 当你执行了 `git reset --hard` 之后，想找回那些被删除的提交。
  * **效果：** `git reflog` 会显示一个操作列表，每个操作都有一个唯一的 `HEAD@{...}` 引用。你可以通过这个引用找到你想要恢复的提交ID。

**如何使用：**

1.  执行 `git reflog` 查看操作历史。
    ```bash
    git reflog
    ```
2.  找到你误删之前的那个提交记录，并复制它的 `commit_id`。
3.  使用 `git reset --hard` 配合这个 `commit_id` 恢复到之前的状态。
    ```bash
    git reset --hard <commit_id>
    ```
    比如，你发现 `HEAD@{1}` 是你想要恢复的状态，那么就执行 `git reset --hard HEAD@{1}`。

### 总结

  * **`git reset`**：**修改** 提交历史。适用于本地分支，不适合已经 `push` 到远程的公共分支。
      * `--soft`：保留修改到暂存区。
      * `--mixed`：保留修改到工作区（最常用）。
      * `--hard`：彻底丢弃所有修改（**慎用**）。
  * **`git revert`**：**新增** 一个提交来撤销更改。适用于公共分支，因为它保留了完整的历史记录，不会影响其他协作者。
  * **`git reflog`**：是你的**后悔药**。当你不知道如何回退，或者不小心回退错了，都可以用它来查看操作历史，然后配合 `git reset` 恢复。